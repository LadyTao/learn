# Java-基础-13-并发&并行-基础知识

# 1 概念

### 1.1 前置知识-操作系统

reference: 

1. http://faculty.salina.k-state.edu/tim/ossg/Introduction/compArch.html
2. https://monkeysayhi.github.io/2017/11/29/%E6%B5%85%E8%B0%88linux%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2/

#### 1.1.1 计算机架构

- 冯诺依曼架构

冯诺依曼架构规定计算机必须具备以下条件：

1. 同时保存指令和数据的可寻址存储器 (register，寄存器)

2. 算术逻辑单元(ALU，+/-/比较、逻辑、位移运算)

3. 一个程序计数器(Program counter)

   > 程序计数器是用于存放下一条指令所在的地址
4. io控制
- 冯诺依曼中 Cpu 包含以下部分：

  1. 寄存器 
  2. 算术逻辑单元(ALU)
  3. 程序计数器(Program counter)
  4. 控制单元(Control unit)

  > CU 就像计算机中的管理员。CU 以指令的形式从 RAM 接收命令，并将该指令解码（分解）为用于计算机系统内其他组件的特定命令。它指导数据流和 ALU 的操作。

- 中断

1. 中断是什么？

> 中断会引发进程的切换，如用户空间到内核空间的转换等。一般中断分为软中断和硬中断(还有缺陷，Cpu自身引起)。
>
> 1. 硬中断，如：硬件设备对CPU的中断，如磁盘、网卡io等。硬中断可抢占软中断，优先级高执行较快。
> 2. **软件中断**是由程序在请求操作系统执行系统调用时生成的。

2. 为什么需要中断？

> 没有中断，cpu必须定期轮询，以了解外部交互需要，期间将会使 Cpu 效率降低。引入中断，Cpu 无需定期轮询外部设备。

3. Cpu 如何响应中断

> CPU 的硬件对每个中断信号执行完全相同的操作，这使得操作系统可以从当前运行的用户进程中夺走控制权(上下文切换)。
>
> CPU 依靠多个寄存器中的数据来正确处理中断(上下文切换)。一个寄存器保存一个指向当前运行进程的进程控制块(PCB)的指针。每次将进程加载到内存中时，都会设置此寄存器。另一个寄存器保存一个指向表的指针，该表包含指向 OS 内核中中断处理程序和系统调用指令的指针。该寄存器中的值和表的内容是在操作系统在引导时初始化时设置的。
>
> CPU 执行以下操作以响应中断(上下文切换)：
>
> 1. 使用指向当前进程控制块的指针，进程的状态和所有寄存器值被保存以供稍后重新启动进程时使用(PCB 现场保存, PCB 是一个数据结构)。
> 2. CPU 模式位切换到内核模式。
> 3. 使用指向中断处理程序表的指针和中断向量，确定要执行的内核代码的位置。中断向量是硬件中断的 IRQ（从中断控制器寄存器中读取）和软件中断的中断汇编语言指令的参数。
> 4. Cpu处理被切换到内核的适当部分。

- Cpu 执行模式(对应内存管理上的用户、内核空间)

  通过`硬件`保证模式的实现，这样做的目的是为了安全(防止系统奔溃，越界访问，权限，资源限制。)。模式分为用户模式和内核模式。用户模式受限于某些指令不能执行，某些寄存器不能访问，I/O 设备不能访问。内核模式没有这些限制。用户模式只能通过系统调用才能间接使用资源，系统调用会引发中断，Cpu切换到内核模式。



#### 1.1.2 操作系统 (Linux 为例)

- 操作系统类型：

      操作系统一般分为实时、批处理、分时系统、分布式等；Linux 是分时系统，通过CPU分片配合调度算法的实现。

- 操作系统常用调度算法：

  先来先服务，短作业优先，优先级(抢占式or非抢占式)，高响应比优先调度算法，时间片轮转，多级反馈队列等。Linux会把进程分为普通进程和实时进程，普通进程采用**`CFS`**之类调度算法，而实时进程则是采用SCHED_FIFO或SCHED_RR算法。Linux 中可以通过调整 nice 值，改变调度优先级。

- 操作系统进程的几种状态

  1. 新建

  > 首次启动进程，执行初始化，分配内存，执行完成后进入就绪态。

  2. 就绪(等待)

  > 代码已经加载到内存中，等待分配cpu。**Linux 只调度就绪状态的线程。任何线程需要调度都需要状态进入到就绪态中。**

  3. 运行

  > 获得 Cpu 时间片运行程序

  4. 堵塞

  > io 调用、时间片轮询等引发进程堵塞

  5. 终止(退出)

  > 进程完成任务，自行退出，或者收到信号量等退出。

  https://en.wikipedia.org/wiki/File:Process_states.svg

  

  - linux 进程状态图

  ![../_images/unix_state.png](http://faculty.salina.k-state.edu/tim/ossg/_images/unix_state.png)

上图对应 ps 列举的线程状态：

1. R Running.运行中
2. S Interruptible Sleep.等待调用D
3. Uninterruptible Sleep.等待磁盘IO
3. T Stoped.暂停或者跟踪状态
4. X Dead.即将被撤销
5. Z Zombie.进程已经结束，仅映像名留存
6. W Paging.内存交换
> 僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。
> 孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。


#### 1.1.3 Linux 中线程 & 进程

1. Linux 内核只有普通进程（进程）、轻量级进程(线程)，**统一使用 `task_struct` 结构体标识**， **PID是进程和线程的唯一标识**， **top 命令默认显示的是进程**，**系统 /proc/数字，数字也是进程号，/系统/proc/数字/task 是线程号**。

> 进程是资源分配的基本单位、线程共享进程的资源，线程是调度的最小单位(cpu运行最小单位)。普通进程需要深拷贝虚拟内存、文件描述符、信号处理等；而轻量级进程之所以“轻量”，是因为其只需要浅拷贝虚拟内存等大部分信息，多个轻量级进程共享一个进程的资源。

2. 进程，线程对应关系

> linux加入了线程组的概念，实现一个进程下可能有多个线程。`task_struct`中，使用pgid表示进程组，tgid表示线程组，**pid表示进程或线程的唯一标识(进程 tgid 不一样，线程 tgid 一样，默认top 命令只显示进程)**。
>
> - 操作系统中存在多个进程组
> - 一个进程组下有多个进程（1:n）
> - **一个进程对应一个线程组**（1:1）
> - **一个线程组下有多个线程**（1:n）
>
> 总结:
>
> - 进程是一个逻辑上的概念，用于管理资源，对应`task_struct`中的资源
> - 每个进程至少有一个线程，用于具体的执行，对应`task_struct`中的任务调度信息
> - 以`task_struct`中的pid区分线程，tgid区分进程，pgid区分进程组

- java 中线程 & 进程

> java 中线程是 Thread 类，进程是通过 ProcessBuilder 创建的一个进程。`线程都在同一个jvm内`，一个jvm 只有一个进程，新进程可以是新的jvm 也可以是非java 类应用运行。

- 内核空间 & 用户空间 (存储空间)

      Linux 内核空间用于运行内核，可以执行任意命令，管理机器任何资源。用户空间用于用户程序运行。用户空间只能直接进行运算，无法直接利用系统资源，当用户程序使用系统资源时，必须通过系统接口才能实现。

- 中断(见计算机架构部分)

  > 中断实现了进程的上下文切换，内核和用户态的切换。

- 同步 & 异步； 堵塞 & 非堵塞

======================================================================

reference :

1. https://github.com/CyC2018/CS-Notes/issues/194

======================================================================

1. 同步/ 异步

   > **同步、异步一般讨论是用户代码层面的问题。**一个耗时的函数调用，等待至返回结果是同步，不等待返回结果，被调用函数马上返回(一般会返回标记号，以供异步查询进展状态；或者是传入回调函数，让被调用者执行完成操作后续流程)；

2. 阻塞/非阻塞(会引发系统调用，linux 网络通信模型为例)

> “阻塞”是指进程在**发起了一个系统调用**（System Call） 后， 由于该系统调用的操作不能立即完成，需要等待一段时间，于是内核将进程挂起为**等待 （waiting）**状态， 以确保它不会被调度执行， 占用 CPU 资源。**注意在任意时刻， 一个 CPU 核心上（processor）只可能运行一个进程** 。



3.  阻塞/非阻塞， 同步/异步的概念要注意讨论的上下文：

- 在进程通信层面， 阻塞/非阻塞， 同步/异步基本是同义词， 但是需要注意区分讨论的对象是发送方还是接收方。

- 发送方阻塞/非阻塞（同步/异步）和接收方的阻塞/非阻塞（同步/异步） 是互不影响的。

- 在 IO 系统调用层面（ IO system call ）层面， **非阻塞 IO 系统调用** 和 **异步 IO 系统调用**存在着一定的差别， 它们都不会阻塞进程， 但是返回结果的方式和内容有所差别， 但是都属于非阻塞系统调用（ non-blocing system call ）

- 非阻塞系统调用（non-blocking I/O system call 与 asynchronous I/O system call） 的存在可以用来实现线程级别的 I/O 并发， 与通过多进程实现的 I/O 并发相比可以减少内存消耗以及进程切换的开销。

  > reference :
  >
  > https://www.zhihu.com/question/19732473/answer/88599695
  >
  > 同步、异步、阻塞、非阻塞，是分3个层次的：
  >
  > 1. CPU层次；
  > 2. 线程层次；
  > 3. 程序员感知层次。
  >
  > 这几个概念之所以容易混淆，是因为没有分清楚是在哪个层次进行讨论。
  >
  > **CPU层次**
  > 在CPU层次，或者说操作系统进行IO和任务调度的层次，现代操作系统通常使用异步非阻塞方式进行IO（有少部分IO可能会使用同步非阻塞轮询），即发出IO请求之后，并不等待IO操作完成，而是继续执行下面的指令（非阻塞），IO操作和CPU指令互不干扰（异步），最后通过中断的方式来通知IO操作完成结果。
  >
  > **线程层次**
  >
  > 在线程层次，或者说操作系统调度单元的层次，操作系统为了减轻程序员的思考负担，将底层的异步非阻塞的IO方式进行封装，把相关系统调用（如read，write等）以同步的方式展现出来。然而，同步阻塞的IO会使线程挂起，同步非阻塞的IO会消耗CPU资源在轮询上。为了解决这一问题，就有3种思路：
  >
  > 1. 多线程（同步阻塞）；
  > 2. IO多路复用（select，poll，epoll）（同步非阻塞，严格地来讲，是把阻塞点改变了位置）；
  > 3. 直接暴露出异步的IO接口，如kernel-aio和IOCP（异步非阻塞）。
  >
  > 
  >
  > **程序员感知层次**
  > 在Linux中，上面提到的第2种思路用得比较广泛，也是比较理想的解决方案。然而，直接使用select之类的接口，依然比较复杂，所以各种库和框架百花齐放，都试图对IO多路复用进行封装。此时，库和框架提供的API又可以选择是以同步的**方式**还是异步的**方式**来展现。如python的asyncio库中，就通过协程，提供了同步阻塞式的API；如node.js中，就通过回调函数，提供了异步非阻塞式的API。
  >
  > **总结**
  >
  > 因此，我们在讨论同步、异步、阻塞、非阻塞时，必须先明确是在哪个层次进行讨论。比如node.js，我们可以说她在程序员感知层次提供了异步非阻塞的API，也可以说在Linux下，她在线程层次以同步非阻塞的epoll来实现。

4.  Linux io 阻塞/非阻塞， 同步/异步

|        | 同步/异步 | 堵塞/非堵塞     |
| ------ | --------- | --------------- |
| select | 同步      | 操作系统决定    |
| poll   | 同步      | 函数timeout控制 |
| epoll  | 同步      | 函数timeout控制 |

- Linux 临界区

> 访问和操作共享数据的代码段。

- Linux 竞态条件

> 当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。（注意这里的顺序一般指的是线程上下文切换导致不同线程交错执行同一份代码，用户认为应该原子操作的行为，实际执行并没有原子操作。）



# 2.  并发问题

### 2.1 安全性问题

> 并发安全：程序结果是否正确，符合逻辑。如：同一变量被多个线程交错累加。

并发安全需要保证几个基本特性：

- **可见性** - 是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，`volatile` 就是负责保证可见性的。

- **原子性** - 简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制（加锁：`sychronized`、`Lock`）实现。
- **有序性** - 是保证线程内串行语义，避免指令重排等。

#### 2.1.1 可见性问题

- 为什么会出现可见性问题

       多核Cpu ，Cpu 缓存和内存不一致导致。线程操作变量时，是直接操作 Cpu 缓存值，而不是内存中的值。在多核环境下，每个 Cpu 都有独立的缓存，导致出现 Cpu 缓存和内存不一致的问题，这就是可见性问题。

- 解决方法：
  1. `volatile` 修饰变量。

#### 2.1.2 原子性问题

- 为什么会出现原子性问题

       count += 1 等类似的一行代码，底层上并不是一条Cpu 指令执行完成的。当线程切换时候，可能上一个线程只完成部分 Cpu 指令。

- 解决办法
  1. 锁，如：synchronized 修饰(synchronized 只能保证有序，利用 jvm monitor 机制，同一时间只能一个线程进入到竞争区代码中，不能禁止指令重排列)。

#### 2.1.3 有序性问题

- 为什么会出现有序性问题

     在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。

- 解决办法
  1. volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。（但是Volatile 不能解决原子性问题。）
  2. synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。注意synchronized 并不能禁止重排序，只是通过锁禁止竞争区代码被多线程同时执行。 

#### 2.1.4 安全性解决方法

- 无同步

1. 无共享变量(只使用线程内部局部变量)或者是只读不变的共享变量

2. ThreadLocal 

> **`ThreadLocal` 为共享变量在每个线程中都创建了一个本地副本**，这个副本只能被当前线程访问，其他线程无法访问。注意，ThreadLocal 可能会引发内存泄漏，使用完后必须手动调用 remove，防止内存泄漏。

- 互斥同步（悲观锁）

> **同步是指在多线程并发访问共享数据时，保证共享数据在同一时刻只能被一个线程访问**。

1. synchronized 

2. ReentrantLock (比synchronized  性能好很多，并且支持)

- 非堵塞同步(乐观锁)

> 互斥同步的缺陷是会引发线程上下文切换(线程堵塞、唤醒消耗)。乐观锁先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。乐观锁利用了硬件指令集实现，因此更加高效。

**乐观锁需要操作和冲突检测这两个步骤具备原子性，因此都是基于硬件指令集实现**;

1. CAS([compareAndSet](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicInteger.html#compareAndSet-int-int-) Java 内部实现)

> reference:
>
> 1. https://tech.meituan.com/2018/11/15/java-lock.html

CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B，java JUC 包封装了各种CAS 的锁实现。

2. 获取并增加（Fetch-and-Increment）、交换（Swap）等其他乐观实现。(一般 Java 没有实现，或者已经弃用的乐观锁实现方式。)

### 2.2 活跃性问题

#### 2.2.1 死锁

- 什么是死锁

多个线程互相等待对方释放锁。

- 死锁的条件
1. 互斥条件：一个资源每次只能被一个进程使用。
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。
  

- 如何解决死锁

1. 超时释放
2. 死锁检测(检测到死锁回换，打破回换)

#### 2.2.2 活锁

- 什么是活锁

与死锁相反，多线程下所有线程都退让，让对方获取锁，最终大家都没有执行操作。

- 如何解决活锁

线程退让等待的时间不一致即可。

#### 2.2.3 饥饿

- 什么是饥饿

某些线程长期不能获得锁(锁总是被高优先级线程获取)。

- 如何避免饥饿

1. 公平锁
2. 动态优先级(提高长时间未获得锁的线程的优先级)

#### 2.2.4 锁的类型
1. 悲观锁 vs 乐观锁
2. 可重入锁 vs 不可重入锁
3. 公平锁 vs 非公平锁
4. 自旋锁 vs 非自旋锁 vs 适应性自旋锁
5. 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁
6. 独享锁 VS 共享锁

### 2.3 性能问题

#### 2.3.1 上下文切换

- 如何减少上下文性能切换损失？

1. 合理的线程数
2. 无锁并发
3. 协程等轻量化线程
4. 自旋锁优化
5. 多写场合使用悲观锁，多读场合使用乐观锁

