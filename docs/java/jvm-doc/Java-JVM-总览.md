# Java-JVM-总览

> reference:
>
> https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html

## 1. 什么是 jvm

     JVM类似物理机，拥有独立指令集，内存管理。 JVM通过抽象操作系统和CPU结构，提供了一种与平台无关的代码执行方法，即与特殊的实现方法、主机硬件、主机操作系统无关运行环境。

## 2. JVM 包含了几个部分

![jvm 架构](https://github.com/Whojohn/learn/blob/master/docs/java/pic/jvm-arch.png?raw=true)

> ps 这个部分十分混乱，oracle jvm 标准划分比较混乱
>
> reference:
>
> https://www.freecodecamp.org/news/jvm-tutorial-java-virtual-machine-architecture-explained-for-beginners/

- ClassLoader（类加载器）

> - 包含以下部分
>
> 1. 三种类加载器：Bootstarp 、Extension 、Application ClassLoader。
> 2. 加载顺序：双亲委派。
> 3. 自定义加载器：SPI 等。
> 4. 类加载流: load link ini

- Runtime Data Area

      jvm 规范中只讲述了必须包含的部分，没有强制要求如何实现，如：方法区放在堆还是直接内存上。！！！注意 jvm 内存和 java 内存模型不是一样的东西，内存模型是共享内存的并发模型，java 内存模型主要跟volatile 实现有关！！！并且jvm 的内存屏障与 hotspot 的写屏障没有任何关系。！！！

> - 包含以下部分
>
> 1. pc register 
>
> 2. jvm stack
>
> 3. native method stack
>
> 4. heap
>
> 5. method area
>
> 6. Run-time Constant Pool(常量池)

- Execution Engine（执行引擎）

> - 包含以下部分
>
> 1. 解释器： 快速解释字节码，但执行却很慢。 解释器的缺点就是,当一个方法被调用多次，每次都需要重新解释。
> 2. jit 编译器：jvm 发现热点代码，会通过 jit 编译器把热点代码编译成本地机器码，防止多次调用解释器，引发性能问题。
> 3. Garbage Collector （垃圾回收器）：cms、g1 、zgc 等具体实现。



- Native Interface（本地库接口）

> **JNI** 会与**本地方法库**进行交互并提供执行引擎所需的本地库

- 本地方法库

  >  它是一个执行引擎所需的本地库的集合。

## 3. JVM 具体实现 - hotspot

> reference:
>
> http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html

### 3.1 Execution Engine(执行引擎相关)

- jit 编译手段：
  1. c1   (client 默认方法)
  2. c2（server 默认方式，比c1 更加优化）

### 3.2 GC 相关( hotspot 特有)

- **block start table**：块起始表
- **card table**：卡表，解决对象相互引用，Minor GC时也必须扫描**完整**老年代(防止老年代持有年轻代对象)，消耗过大的问题。**卡表**的具体策略是将老年代的空间分成大小为512B的若干张卡（card）。卡表本身是单字节数组，数组中的每个元素对应着一张卡，当发生老年代引用新生代时，虚拟机将该卡对应的卡表元素设置为适当的值。**卡表还有另外的作用，标识并发标记阶段哪些块被修改过**(因为 cms 并发标识其他线程也在同时修改对象，需要通过卡表，记录那些对象在并发阶段被修改了。)。
- **write barrier**: **hotspot 写屏障对一个对象引用进行写操作（即引用赋值）之前或之后执行特定操作。实现了标识并发标记阶段被修改的对象。**
- **GC map（oopmap）**：OopMap 记录了栈中那些对象是引用对象。它的主要目的是在 Java 堆栈上找到 GC 根，并在对象在堆内移动时更新引用。
- **young generation**(g1不区分)：年轻代
- **old generation**(g1不区分)：老年代
- **eden**
- **survivor spce** 
- 内存泄露
- 内存溢出
- 分区担保
- 动态老年代
- cms 浮动垃圾
> GC 线程和用户线程并发执行，这个过程当然可能会因为线程的交替执行而导致新产生的垃圾（即浮动垃圾）没有被标记到；

### 3.3 对象相关

#### 3.3.1 对象创建流程

- 对象的创建流程

  1. 类加载检测
  > 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。
  >
  > `import env.TestUtil;` 这种就是一个符号的引用
  2. 分配内存
  >         在**类加载检查**通过后，接下来虚拟机将为新生对象**分配内存**。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**。并发控制是通过`cas`+失败重试实现。
  >
  > - 指针碰撞
  >
  >     对于规整的内存，中间有指针，指针后面的区域是可用区域，分配空间，移动指针即可。
  >
  > - 空闲列表
  >
  >   维护一个列表，标识内存哪些区域可以使用。
  3. 初始化零值
  > 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
  4. 设置对象头
  > 初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。** 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。
  5. 执行 init 方法
  > 执行 `<init>` 方法，进行真正初始化，这样一个真正可用的对象才算完全产生出来。

- 分配内存细节

> 预先分配：TLAB，每个线程中都有预先分配 TLAB 内存，分配对象内存先尝试分配TLAB空间，失败走并发分配。TLAB 只能存在于一个GC周期中，GC后，会把数据移出 TLAB区域。
>
> 并发分配安全：cas+失败重试

#### 3.3.2 对象的内存布局

1. 对象头

   > **Hotspot 虚拟机的对象头包括两部分信息**，**第一部分用于存储对象自身的运行时数据**（哈希码、GC 分代年龄、锁状态标志等等），**另一部分是类型指针**，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。

2. 实例数据

> **实例数据部分是对象真正存储的有效信息**，也是在程序中所定义的各种类型的字段内容。

3. 对齐填充

> **对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。**

#### 3.3.3 对象的访问与定位

- 访问定位方式
> 无论是哪种访问方式，都必须解决，访问实例数据和对象类型数据访问的方法。
1. 使用句柄

2. 直接指针

#### 3.3.4 对象的引用方式

1. 强引用：对象只有在没有引用的情况下才能被gc。
2. 软引用：当内存不足时，尝试回收软引用对象，一般用于缓存。
3. 弱引用：下一次gc必须会回收的对象。
4. 虚引用：一般用于监听系统gc情况。

#### 3.3.4 对象的死亡

- finalize

- 二次标记

#### 3.3.5 java 内存指针压缩

- 为什么需要指针压缩？
  JVM 运行在64位时候，对象的指针会比32位时候数值更大，消耗更多的内存空间，cpu 能缓存的指针也会变少。因此jvm利用压缩指针的方式，以32位表达64位的空间，可以减少这些消耗。
- 为什么jvm 大小不能超过32G？
  1. 当jvm内存大小超过32G，64位系统下，默认指针压缩算法失效，只能以64位保存指针信息。
  2. cms 等gc 算法在jvm 超过32G下表现更差。