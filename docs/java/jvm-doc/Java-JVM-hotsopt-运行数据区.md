# Java-JVM-hotsopt-运行数据区

> reference:
>
> https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.md
>
> https://github.com/dunwu/javacore/blob/master/docs/jvm/jvm-memory.md
>
> **周志明《深入理解 Java 虚拟机》**

## 1. Java 内存区域 (运行时数据区)

> 注意！！！jmm 是 java 内存模型，说的是 volatile 相关的问题，与jvm 没有必然联系！！！https://en.wikipedia.org/wiki/Java_memory_model

![jvm 架构](https://github.com/Whojohn/learn/blob/master/docs/java/jvm-doc/pic/jvm-arch.png?raw=true)

### 1.1 栈(内存不共享区域)

> pc（程序计数器）：指向下一条需要指向的命令。**分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。**不会出现`OutOfMemoryError`区域。
>
> jvm stack:  每个方法的执行都会产生栈帧，栈帧存放了：**编译期可知局部变量表、操作数栈、动态链接、方法出口**。方法的调用开始到完结对应栈帧在 `jvm stack` 中入栈出栈的过程。
>
> native stack: **本地方法栈为 Native 方法服务**。本地方法并不是用 Java 实现的，而是由 C 语言实现的。

**jvm stack内栈帧包含以下结构**
- 局部变量表:32 位变量槽，存放了编译期可知的各种基本数据类型、对象引用、ReturnAddress 类型。
- 操作数栈: 基于栈的执行引擎，虚拟机把操作数栈作为它的工作区，大多数指令都要从这里弹出数据、执行运算，然后把结果压回操作数栈。
- 动态链接:每个栈帧都包含一个指向运行时常量池（方法区的一部分）中该栈帧所属方法的引用。持有这个引用是为了支持方法调用过程中的动态连接。Class 文件的常量池中有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另一部分将在每一次的运行期间转化为直接应用，这部分称为动态链接。
- 方法出口:返回方法被调用的位置，恢复上层方法的局部变量和操作数栈，如果无返回值，则把它压入调用者的操作数栈。

### 1.2 堆

>  **除了`TLAB`以外，其他堆内存共享该区域。**注意 G1 ZGC 划分不再是以下的划分方式。以下是cms的划分方式，分代划分。

#### 1.2.1 分代技术

> 分代技术把堆划分为年轻代和老年代，不同的区域，采用不同的垃圾收集器。

- Yong Generation：年轻代 默认占总比率为：1：3，由`-XX:NewRatio=3`参数控制。 Eden 和 Survivor 的比例为 8:1；注意年轻代`GC`的时候只在乎老年代是否引用了年轻代，导致无法回收对象这种情况。

Eden：大部分情况，对象都会首先在 Eden 区域分配。

TLAB：`Eden`中为每一个线程都独立分配了一个`TLAB`，只有当`TLAB`分配失败，才会去`Eden`区申请空间，使得内存分配的并发冲突降低。`TLAB`每一轮 `GC` 都会被清除数据。

Survivor：`Eden` 与 `Survivor` 比率是`4：1`，两者构成标记复制算法的具体实现。


- Old Generation：老年代，用于存放`大对象直接放入老年代`，`多轮gc后仍然存在的对象`，`空间分配担保`等场景。

- **分代技术如何分配内存：**

1. 优先分配`TLAB`空间，假如`TLAB`空间已满，或者对象过大，尝试分配`Eden`区内存。
2. `Eden`区检测对象是否过大，过大直接放入到`Old Generation`区域（**大对象直接放入老年代**）。假如`Eden`区域，空间不足，触发`Young GC`。执行标记-复制算法，把年龄段超大的数据放入到`Old`区域(**多轮gc后仍然存在的对象**)，剩余的保存在`Survivor`的`to`区域，假如`Survivor`空间不足，余下部分都放入到`old`区域(**空间分配担保**) 。old`区域不足时触发`old`区域`GC`。

#### 1.2.2 分区技术(G1 ZGC)

### 1.3 方法区(内存共享区域)

> 特别的，hotspot 把方法区的实现拆分为：内存和堆2部分构成。
>
> - 常量池(存放在内存)：
> - 非常量池：虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

### 1.4 直接内存

> native 方法执行的内存区域，还有`hotspot`方法区非常量池存放的实现。

## 2 对象死亡判定

> 注意，堆中对象死亡的判定和方法区中死亡的判定是有细节上的不同，方法区的对象死亡判定在普通对象死亡判定的基础上，还需要有额外的判定。

### 2.1 对象的引用与对象回收关系

1. 强引用：对象只有在没有引用的情况下才能被gc。
2. 软引用：当内存不足时，尝试回收软引用对象，一般用于缓存。
3. 弱引用：下一次gc必须会回收的对象。
4. 虚引用：一般用于监听系统gc情况。

### 2.2 判定对象是否能被回收(对象是否已无效)

**判定对象能否被回收有以下的方法：**

1. 引用计数：当一个对象增加一个引用时候，计数器加一，该算法需要额外的算法才能解决循环引用的问题。(**Python就是引用计数，一样解决了循环引用的问题。**)

2. 可达性分析算法(jvm采用的方法)：以 `GC Roots` 作为起点搜索，所有可达的对象都标记为存活。**注意，hotspot 有老年代，存在跨代引用问题，老年代引用了年轻代的对象，为了减少消耗，引入卡表，避免扫描整个老年代。**

>  - `GC Roots定义`：
>
>  1. `jvm stack`中引用的对象
>  2. 本地方法`stack`中`jni`引用的对象
>  3. 方法区中，类静态属性引用的对象
>  4. 方法区中，常量引用的对象
>
>  - JVM 中如何执行可达性算法（`Finalize`导致需要二次标记）
>
>  1. 可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 `Finalize`方法。当对象没有覆盖 `Finalize`方法，或 `Finalize`方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行`2`的检测。
>  2. 被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。
>
>  - 不可达对象是否一定是死亡了？(堆中对象如何判定为死亡？为什么需要二次标记？JVM 是通过二次标记实现的。)
>
>  > 否。`Java Object` 中有一个 `Finalize`方法，默认回收前会调用一次这个方法。为了防止出现该对象在用户定义`Finalize`方法时候，再次引用了该对象(导致该对象无法释放)，因此会先放入到队列，然后队列中进行二次判定，防止`Finalize`引发引用；



### 2.3 方法区的对象回收判定

> Hotspot 中将方法区分为：常量池（堆），非常量池（直接内存）；两种实现。对于堆来说没有任何图书的处理。但是对于非常量池部分有如类的清除，是特殊的。

- 清除一个类需要满足(如何清除类占用的内存空间)

1. 所有该类的实例都被回收，堆中不存在该类的任何实例。
2. 加载该类的`ClassLoader`也被回收了。
3. 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。



## 3. 垃圾算法

### 2.2 垃圾收集算法

> 当经过`对象回收判定`算法的标识过可以回收的内存区域，下一步就是通过垃圾回收算法，回收这些空间。Hotspot 中假如使用分代模型，一般年轻代使用是复制，老年代使用的是：清除或者是整理(cms 是先清除，后整理)。

#### 2.2.1 标记-清除
![标记-清除](https://github.com/Whojohn/learn/blob/master/docs/java/jvm-doc/pic/jvm-gc-mark-sweep.jpg?raw=true)

#### 2.2.2 标记-整理

![标记-整理](https://github.com/Whojohn/learn/blob/master/docs/java/jvm-doc/pic/jvm-gc-mark-compact.jpg?raw=true)

#### 2.2.3 复制(Eden,Survivor的存在的意义)

![复制](https://github.com/Whojohn/learn/blob/master/docs/java/jvm-doc/pic/jvm-gc-copying.jpg?raw=true)

### 2.3 垃圾收集器

- 为什么内存要分代

不同区域使用不同的垃圾收集算法。**注意，`G1`，`ZGC`等已经没有分代的概念。**

-  `Minor GC `  && `Young GC` && `Old GC` && `Full GC` 联系与区别

`Minor gc` = `Young gc`;

`Old GC` != `Full GC`；`Old GC` 如`CMS`可以只回收`Old`区域，但是`Full GC`必须回收整个堆空间。

- oopmap

>        `GC Roots` 扫描完整的栈会很慢，`hotspot `通过引入 `oopmap` 把栈中的对象引用记录在`oopmap`中，以空间换时间，加快可达性分析算法的速度。

- 安全点

>       每一条命令都频繁的修改`oopmap`会引发性能下降，`hotspot`通过引入安全点，在执行一些特定的操作时(只有到达安全点时)，才允许修改`oopmap`。`hotspot`的`GC`也只能在安全点执行。

- 安全区域

>       `sleep`或`block`状态的线程无法马上进入到安全点，此时假如需要`GC`，`hotspot`会认为当前进入到安全区域中，在这个阶段`oopmap`不会改变，那么`hotspot`执行`gc`是安全的。**但是，该线程退出安全区域时候，必须要检测是否gc正在执行，假如正在执行，必须等待gc完成。**

### 2.3.1 Serial 收集器

GC 会 `STW`。

![Serial 收集器](https://github.com/Whojohn/learn/blob/master/docs/java/jvm-doc/pic/gc-serial.jpg?raw=true)

#### 2.3.2  ParNew 收集器

**ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为和 Serial 收集器完全一样。**

![ParNew 收集器](https://github.com/Whojohn/learn/blob/master/docs/java/jvm-doc/pic/gc-parnew.jpg?raw=true)

### 2.3.3 CMS 收集器(只应用于老年代中)

> gc 时候先尝试使用标记-清除，假如剩余空间不足，使用标记-整理算法处理。

![cms](https://github.com/Whojohn/learn/blob/master/docs/java/jvm-doc/pic/gc-cms.jpg?raw=true)

- `cms old gc`工作流程如下

1. 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。

2. 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。

3. 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。

4. 并发清除：不需要停顿(因为安全点和安全区域的存在)。

- **CMS Full GC **

**cms old gc 无法回收足够的内存，将会退化为其他标记-整理算法，以释放old 区域。**

